[
  
  {
    "title": "数据库实验报告",
    "url": "/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/",
    "categories": "专业基础知识, 数据库系统概论",
    "tags": "数据库系统概论实验",
    "date": "2024-01-03 16:46:00 +0800",
    





    
    "snippet": "实验目的  学习关系数据库语言 SQL 基本语句操作  学习关系数据库的安全性操作  学习关系数据库的完整性操作实验平台  操作系统：windows 10  使用软件:          版本控制软件：Git      数据库管理系统：MySql数据库管理系统      实验前准备Git，mysql安装配置实验内容第一部分实验  mysql语句练习1.定义模式[例3.1]为用户WANG定义一...",
    "content": "实验目的  学习关系数据库语言 SQL 基本语句操作  学习关系数据库的安全性操作  学习关系数据库的完整性操作实验平台  操作系统：windows 10  使用软件:          版本控制软件：Git      数据库管理系统：MySql数据库管理系统      实验前准备Git，mysql安装配置实验内容第一部分实验  mysql语句练习1.定义模式[例3.1]为用户WANG定义一个学生课程模式S-T总结：mysql中模式对象名称规范：（详细内容参考）遗留问题20201020：mysql如何为指定用户创建数据库？​\t先用指定用户登录，再使用该用户创建数据库基本表的定义、删除与修改[例3.5]建立一个学生表student；SQL语句创建基本表：可以看到，创建表成功，SQL创建表的语法可以在mysql中使用MySQL语法：  创建表相关扩展知识：  表名：可以将表名指定为 db_name.tbl_name在特定数据库中创建表。不管是否存在默认数据库（假定数据库存在），此方法都有效。如果使用带引号的标识符，请分别为数据库和表名加上引号。例如，写 mydb`.`mytbl而不是 mydb.mytbl。  临时表：您可以TEMPORARY在创建表时使用关键字。一个TEMPORARY表仅在当前会话中可见，并且在关闭会话时会自动删除。  表复制和克隆：            LIKE      用于CREATE TABLE ... LIKE根据另一个表的定义创建一个空表，包括在原始表中定义的任何列属性和索引：      CREATE TABLE new_tbl LIKE orig_tbl;                    [AS] *query_expression*      要从另一个表创建一个表，请在SELECT语句末尾添加一条 CREATE TABLE语句：      CREATE TABLE new_tbl AS SELECT * FROM orig_tbl;                           [例3.8]向student表增加“入学时间”列，其数据类型为日期型[扩展]向刚才创建的三个表中插入数据时可能遇到的问题及解析      向学生表中插入数据，执行脚本in_student.txt        修改脚本的编码方式为utf-8，插入成功            向课程表中插入数据，脚本in_course.txt        有三条插入成功，其他的都有错误信息，（错误信息说明：外键约束失败，具体是在cpno引用course表的cno时出了问题）    我们先查看表定义时，哪些属性存在外键引用          [例3.9]将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数MySQL语法：ALTER TABLE tbl_name    [alter_option [, alter_option] ...]    [partition_options]       alter_option:   {    table_options     CHANGE [COLUMN] old_col_name new_col_name column_definition        [FIRST | AFTER col_name]   }[扩展]：有数据的情况下列属性的更改      int→char（变更成功）            char→int（变换成功）            char→int(变换失败)            可以看到，同样是char转换为int，sage字段可以成功，但sdept却失败了，由此可见，mysql在进行数据转换时，可以识别char类型的内容  [例3.11]删除student表[总结]MySQL不支持级联删除，cascade，restrict在mysql中不起作用[例3.12]若表上建有视图，选择restrict时表不能删除，选择cascade时可以删除表，视图也将被自动删除；创建视图表is_student删除表student[扩展]CREATE    [OR REPLACE]    [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]    [DEFINER = user]    [SQL SECURITY { DEFINER | INVOKER }]    VIEW view_name [(column_list)]    AS select_statement    [WITH [CASCADED | LOCAL] CHECK OPTION]  create view  的or replace 参数：      show full tables 命令      例 [3.31] 查询姓“ 张成” 且全名为三个汉字的学生的姓名数据库字符集为 ASCII 时 一 个 汉 字 需 要 两 个 “_“当 字 符 集 为 GBK 时只需要一个”_“。[例 3.54] 查询每个学生的学号、 姓名、 选修的课程名及成绩。本查询涉及三个表， 完成该查询的 SQL 语句如下：SELECT Student.Sno,Sname,Cname,GradeFROM Student,SC,CourseWHERE Student.Sno=SC.Sno AND SC.Cno=Course.Cno;[例3.56]查询选修了课程名为“信息系统”的学生学号和姓名小结例3.56中，子查询的查询条件不依赖于父查询，称为不相关子查询[例3.57]找出每个学生超过他自己选修课程平均成绩的课程号（带有比较运算符的子查询）小结例3.57是相关查询，子查询中需要父查询的信息，本题中相当于两层的for循环[例3.58]查询非计算机科学系中比计算及科学系任意一个学生年龄小的学生姓名和年龄（带any或all的谓词子查询）用聚集函数实现：any：比子查询中某个值小，相当于小于最大值all：比子查询中所有值小，相当于小于最小值还可以使用！=any：表示不等于子查询中的某个值​\t\t\t\t\t！=all：表示不等于子查询中的所有值[例3.59]查询非计算机科学系中比计算机科学系中所有学生年龄都小的学生姓名及年龄如3.58，该例也可用聚集函数实现，只需要将3.58中的max改为min[例3.62]查询选修了全部课程的学生姓名[分析]设命题P（x,y)：x选修了y课程问题转化成：\\(\\forall yP(x,y)\\)由于mysql中没有全称量词，将全称量词转化为存在量词如下：\\(\\neg (\\exists  y\\neg P(x,y))\\)以下表中的数据为例分析代码逻辑：                   课程c1      课程c2      课程c3                  学生s1      1      0      0              学生s2      1      0      1              学生s3      1      1      1              学生s4      1      1      0      从程序的角度理解：两个select可以看做双重for循环，如下for(student : s){    for(course : c)    {        判断P(s,c)是否在SC表中    }}  外层for选中s3，内层for选中c1，此时就是判断P(s3,c1)是否为真  P（s3,c1）为真，标号①select选中的就不是空集，标号②返回假，select course在这一步没有选中c1  内层for循环指向c2，P（s3,c2），标号②返回假，select course 在这一步没有选中c2  内层for循环指向c3，P（s3,c3），标号②返回假，select course 在这一步没有选中c3  内层for循环执行完毕，select course 为空，标号③返回真，select student选中当前学生s3从量词的角度理解：\\[\\neg (\\exists  y\\neg P(x,y))\\]\\[\\exists y：对当前的x,扫描所有y,看是否 存在 使\\neg P(x,y)为真的（即P(x,y)为假的）数据\\\\\\ \\\\例如，对于s3，不存在使\\neg P为真的，即\\exists  y\\neg P(x,y)为假，此时外层\\neg (……)为真\\][例3.63]查询至少选修了201215122选修的全部课程的学生姓名                   课程c1      课程c2      课程c3                  学生s1      1      0      0              学生s2      1      0      1              学生s3      1      1      1              学生s4      1      1      0      从谓词角度分析\\[\\begin{align}&amp;命题P:学号为201215122的学生选修了课程y\\\\&amp;命题Q:学号为x的学生选修了课程y\\end{align}\\\\ \\\\\\问题可转化为：查询满足“只要201215122选修了课程y，x也选修了课程y”的学生\\]重点在对 “存在y” 的理解：以上表为例，对学生s3，扫描所有课程，看是否存在一门课满足学号201215122（假设是s4）选了，但是s3没有选，如果存在则命题为假，即s3不满足条件，如果不存在，则命题为真，s3满足条件；由表中数据可知s3满足条件，把s3加入满足条件集合中，对其他学生执行同样操作从代码角度分析，可以看做两层for循环for(scx.sno:sc){\tfor(scy.cno:sc)\t{\t\t判断sc中是否不存在（sno=scx.sno,cno=scy.cno)\t\t且满足scy.sno=201215122  的记录\t\t\t}}假设s4学号就是201215122当外层for循环选中s3时，scx.sno指向s3，scy.cno指向c1,（此时判断条件变为（s3,c1)是否在sc中，且（s4,c1)也在sc中），图中标号①为真，标号②为真，故第二个where 后的条件为假scy.cno指向c2,（此时判断条件变为（s3,c2)是否在sc中，且（s4,c2)也在sc中），图中标号①为真，标号②为真，故第二个where 后的条件为假scy.cno指向c3,（此时判断条件变为（s3,c3)是否在sc中，且（s4,c3)也在sc中），图中标号①为真，标号②为假，故第二个where 后的条件为假此时第二个select为空集，第一个select选中当前学生s3[例3.66]查询计算机科学系的学生与年龄不大于19岁的学生交集  mysql中不支持对查询结果取交集，可以用对查询条件取并替代[例3.68]查询计算机科学系的学生与年龄不大于19岁的学生的差集  差集：A-B:A与（B的补集）的交集[例 3.85] 建立信息系学生的视图， 并要求进行修改和插入操作时仍需保证该视图只有信息系的学生查看视图定义（show create view is_student)：尝试增加记录到is_student表：（可以看到，插入的记录不满足sdept=‘is’时，系统会拒绝，并给出错误信息）尝试修改sdept字段：[扩展]为什么通过视图表可以修改基本表中的数据2020115？视图表是逻辑表，并不是真正的表，视图表中只存储了表结构，数据只有一份是存在基本表中[例 3.86] 建立信息系选修了 1 号课程的学生的视图（ 包括学号、 姓名、 成绩）。视图不仅可以建立在一个或多个基本表上， 也可以建立在一个或多个已定义好的视图上， 或建立在基本表与视图上。[例 3.92] 在信息系学生的视图中找出年龄小于 20 岁的学生。通过视图查询时，先转换成对基本表的查询，称为视图消解，本例中先转换成：SELECT Sno,SageFROM StudentWHERE Sdept='IS, AND Sage&lt;20;第二部分实验 数据库安全性[例 4.1] 把查询 Student 表的权限授给用户 U1错误内容是3118004667这个用户给其它用户授权时被拒绝了，查看资料发现MySQL中除了管理员用户之外，其他用户只能使用自己拥有 的权限，而不能传播该权限（即把该权限授权给其他用户）  如果指定了 WITH GRANT OPTION 子句， 则获得某种权限的用户还可以把这种权限再授予其他的用户。 如果没有指定 WITH GRANT OPTION 子句， 则获得某种权限的用户只能使用该权限， 不能传播该权限。下面先为3118004667@localhost用户授予grant option特权再次为test用户授予访问student表的权限，可以看到授权成功[扩展]创建两个用户test，test1用于测试以上内容先向test授予select特权并指定 with grant option ，测试是否test只拥有对select权限的传播性向test授予新的权限insert由test将insert权限授予test1可以看到授权成功了，但是在通过show grants查看test1拥有的权限的时候，错误提示：test用户没有权限访问user表；切换到test1用户查看test1拥有的权限[例 4.2] 把对 Student 表和 Course 表的全部操作权限授予用户 U2 和 U3*注意：[例 4.4] 把查询 Student 表和修改学生学号的权限授给用户 U4[例 4.8] 把用户 U4 修改学生学号的权限收回。执行如下代码时报错：REVOKE UPDATE(Sno)ON TABLE StudentFROM U4;[遗留问题20201115]撤销某种类型的权限时只对所有列撤销？[例 4.10] 把用户 U5 对 SC 表的 INSERT 权限收回。REVOKE    priv_type [(column_list)]      [, priv_type [(column_list)]] ...    ON [object_type] priv_level    FROM user_or_role [, user_or_role] ...REVOKE ALL [PRIVILEGES], GRANT OPTION    FROM user_or_role [, user_or_role] ...REVOKE PROXY ON user_or_role    FROM user_or_role [, user_or_role] ...REVOKE role [, role ] ...    FROM user_or_role [, user_or_role ] ...user_or_role: {    user (see Section 6.2.4, “Specifying Account Names”)  | role (see Section 6.2.5, “Specifying Role Names”.}从mysql官方文档中可以看到，mysql中没有级联删除权限的选项cascade[例 4.11] 通过角色来实现将一组权限授予一个用户。创建角色然 后 使 用 GRANT 语句， 使角色 R1 拥有 Student 表的 SELECT UPDATE INSERT权限。将这个角色授予王平、 张明、 赵玲， 使他们具有角色 R 1 所包含的全部权限。当然， 也可以一次性地通过 R1 来收回王平的这三个权限[例 4.14] 建立计算机系学生的视图， 把对该视图的 SELECT 权限授予王平， 把该视图上的所有操作权限授予张明。创建视图cs_student把对该视图的 SELECT 权限授予王平把该视图上的所有操作权限授予张明第三部分实验 数据库完整性[例5.3]定义SC中的参照完整性[扩展]创建表时添加外键create table tablename(colname datatype,....,FOREIGNKEY[index_name](col_name,...)REFERENCES tbl_name(col_name,...));已定义的表中添加外键ALTER TABLE tbl_nameADD[CONSTRAINT[symbol]]FOREIGNKEY[index_name](col_name,...)REFERENCES tbl_name(col_name,...)[ON DELETE reference_option][ON UPDATE reference_option][例5.4]显式说明参照完整性的违约处理示例。  ondeletecascade:当删除Student表中的元组时，级联删除SC表中相应的元组  ondeleteonoaction:当删除Course表中的元组造成与SC表不一致时，拒绝删除msyql标准中，没有指定ondelete和onupdate的选项时，默认选项是noaction,所以showcreatetable中并没有显示noaction选项，因为它是默认选项;  ForanONDELETEorONUPDATEthatisnotspecified,thedefaultactionisalwaysNOACTION.[例5.5]在定义SC表时，说明Sno、Cno、Grade属性不允许取空值。[例5.6]建立部门表DEPT,要求部门名称Dname列取值唯一，部门编号Deptno列为主码。[例 5.7] Student 表的 Ssex 只允许取“ 男” 或“女”。[check 扩展]msyql8.0.16后对check的支持更加完善constraint 选项可以为检查约束指定名字expr：布尔表达式enforced：创建约束并且强制执行not enforced: 创建约束但是不强制执行例如：CREATE TABLE t1(  CHECK (c1 &lt;&gt; c2),  c1 INT CHECK (c1 &gt; 10),  c2 INT CONSTRAINT c2_positive CHECK (c2 &gt; 0),  c3 INT CHECK (c3 &lt; 100),  CONSTRAINT c1_nonzero CHECK (c1 &lt;&gt; 0),  CHECK (c1 &gt; c3));      第一个约束是表约束：它发生在任何列定义之外，因此它可以（并且确实）引用多个表列。此约束包含对尚未定义的列的前向引用。没有指定约束名称，因此MySQL会生成一个名称。    接下来的三个约束是列约束：每个约束都出现在列定义中，因此只能引用所定义的列。约束之一被明确命名。MySQL为其他两个生成一个名称。    最后两个约束是表约束。其中之一被明确命名,MySQL为另一个生成一个名称  实验总结遇到问题要注意以下几点：1.找课本。看是否是因为原理没搞清楚导致的错误2.查mysql官方文档。  老师一直强烈推荐我们用PDF版的，个人觉得还是在线的好用，因为是全英文的，在遇到问题是本来就是出于不懂得状态，再去看英文文档更完蛋了，当然，机器翻译的可能个别地方与真实想表达的意思并不相符，我的做法是先看机器翻译，大致理解之后再切换回英文，或者发现明显机器翻译的让人无法理解，再切换回英文，这样更能专注于问题本身，不会被一堆生词干扰。  在文档的时候要善于利用搜索功能，比如创建表时出了问题需要查文档，我就可以搜索create table，如果你不知道要搜的关键词是什么，比如，我想为已经建好的表中的某个属性添加外键，不知道这个语句的关键词是什么，这时候可以先查百度，看看关键词是什么，再回来用查到的关键词搜文档，不建议直接看百度，百度的答案确实很多坑。  有些语句语法中列出了一堆，不要被吓到，其实你需要用到的可能只是某一个选项，找到它，只看这个选项对应的解释，解释中一般都会有例子，结合例子更容易理解"
  },
  
  {
    "title": "补码的原理",
    "url": "/posts/%E8%A1%A5%E7%A0%81%E7%9A%84%E5%8E%9F%E7%90%86/",
    "categories": "专业基础知识, 计算机组成原理",
    "tags": "补码",
    "date": "2023-07-15 23:13:00 +0800",
    





    
    "snippet": "补码为什么能把减法转换成加法01 补码的核心思想——模算术首先，能把减法转换成加法的前提一定是有限的数据表示范围，例如钟表的12个整数（可以表示1~12，也可以是-10~1等等）、64位计算机的$2^{64}$（可以表示有符号数 $-2^{63}\\sim2^{63}-1$  ，或者无符号数$ 0 \\sim 2^{64}-1$）。如果没有任何像前面的条件，直接问你$4-2$应该等于4加哪一个正...",
    "content": "补码为什么能把减法转换成加法01 补码的核心思想——模算术首先，能把减法转换成加法的前提一定是有限的数据表示范围，例如钟表的12个整数（可以表示1~12，也可以是-10~1等等）、64位计算机的$2^{64}$（可以表示有符号数 $-2^{63}\\sim2^{63}-1$  ，或者无符号数$ 0 \\sim 2^{64}-1$）。如果没有任何像前面的条件，直接问你$4-2$应该等于4加哪一个正整数，那一定是不存在的，即   $4-2=4+x  $   中正整数x不可能存在。但是，如果有了一个有限的数据表示范围，利用”模算数“就可能求出上面的x。  模算数或称同余运算（英语：Modular arithmetic）是一个整数的算术系统，其中数字超过一定值后（称为模/馀数）后会“卷回”到较小的数值，模算数最早是出现在卡尔·弗里德里希·高斯在1801年出版的《算术研究》一书中。就像钟表的算术系统中，$12+1=1$ ，这个过程就是 ” 卷回 “。需要注意的是，其中加法的加数、被加数，都必须在你所选定的数据表示范围内，显然对于这个范围外的数都属于非法的数。上面的钟表系统中，如果你选定的12个连续整数是 -6~5，我们尝试在这个算术系统中计算上面的x，在钟表系统中，-2也就是逆时针旋转2个单位，相当于顺时针旋转10个单位，所以-2在钟表算术系统中就等于10，上面的4-2就应该等于4+10=2。  -2等价于10 是如何求的？4+10=2是如何求的？  首先，还是要强调，这两个运算的前提都是在有限的数据表示范围内，这里有限的数据范围就是-6到5，共12个数。  如果你能画出钟表的示意图，这些问题是很直观可以看出来的，当然这个过程也有严格的数学运算的定义，即$mod$模算术：  若有两个正整数a和b，并且二数的差值a−b为n的整数倍数，我们就可以说a和b在模n下同余或a与b同余模n。  数学式表达为：$a \\equiv b\\mod n$  注意，a可以有许多值，只要满足上面的定义。例如：      $-8 \\equiv 7 (\\mod 5)$    $-3 \\equiv 7(\\mod 5)$    $2 \\equiv 7 (\\mod 5)$    mod右侧的数其实就是该算术系统中的数字个数，也可以理解成周期函数的周期。  虽然定义如此，但是大多数编程语言中的模算术运算（一般用%表示），结果都是一个确定值，应该选取哪个呢，不同的编程语言有不同的定义，IEEE 754 定义了一个取余函数，商被定义为 $\\dfrac{b}{n}$依据舍入约定取整，余数选定为最接近0的。根据上面的理论，对于任何一个mod运算，如果算术系统中的数字比较少，你完全可以尝试将其看做一个钟表，算术系统中有几个数，就把钟表等分为几份，数据范围是多少就依次标出每个刻度处的数字。由得到的新的钟表，对任何算术系统中的数，你都把其转化成同余数字进行计算。例如，假设一个算术系统中有8个数，数据范围是-4到3，则你所得到的钟表从最上方的数字顺时针依次是：3、-4、-3、-2、-1 、0 、1 、2。根据这个钟表，就可以实现用加法代替减法，例如：$3-4=3+(-4)=3+4=-1$，即共8个数的钟表上逆时针走4个单位，等于顺时针走4个单位。在上面等式中有$3-4=3+4$即$7=-1$，这在一般情况下当然是错误的，但是在当前只有8个数的算术系统中，就是正确的，其实更严谨的写法应该是$7\\equiv -1 (\\mod 8) $，即$7和-1$同余模8。结合刻度为12的钟表例子，定义中模为5的同余数例子，以及模为8的例子，不难发现，在数据表示范围内的负数对应的最小同余正数，其实就是把该负数加上算术系统中数字个数。  为什么要计算最小同余正数，而不是随便取一个同余正数  理论上取任何一个同余正数，最终的结果都是一样的，用周期函数的思想，其实就相当于多加了一个周期，用钟表的思想，相当于钟表顺时针多转了一圈，指向的还是同一个位置。但是数字越大，就越难计算。同时最小同余正数也符合IEEE754对模运算符的定义。02 补码是如何实现加法代替减法的下面我们开始基于上面的思想分析补码的原理：上面多次强调，模算术的前提是有限数据范围的算术系统，计算机显然符合这个条件，即使是现在主流的64位计算机，能表示的数据范围仍然是有限制的（最大是$2^{64}-1$），这就非常nice，因为我们可以按照上面的思想，画出来一个超大钟表，有$2^{64}-1$个刻度，假设现在我们要计算有符号整数，那么数据范围应该是$-2^{63}\\sim 2^{63-1}$。在这个范围内我们尝试用加法代替减法计算$4-2$：      第一步显然是计算$-2$对应的最小同余正数：$-2\\mod2^{64}$        用加法代替减法，计算$4+(-2\\mod2^{64})$        具体过程：  \\[4-2=4+(-2\\mod2^{64})=\\underbrace{0\\cdots 04 }_{16}H+\\underbrace{F\\cdots FE }_{16}H=1\\underbrace{0\\cdots 02 }_{16}H=2\\]上面的步骤中，我们没用到经常听到的求补码的规则（原码取反加一），但是仍然得到了正确结果。即使没有所谓的补码定义，我们好像也能用最小同余正数的概念，实现用加法代替减法的目的，那为什么还会出现补码的定义，以及求补码的规则呢？  首先明确的是，如果没有补码，计算机中是无法实现加法代替减法的，当然手算可以。如果仔细思考上面求最小同余数的过程，不难发现，$-2\\mod2^{64}=-2+2^{64}$本质上还是一个减法，所以你在尝试用加法替换减法的过程中又使用了减法，这显然是不合理的。  但是这个过程告诉我们可以通过一个正数$-2\\mod2^{64}$，代替-2，实现用加法代替减法，现在就是要想办法不通过减法计算$-2\\mod2^{64}$，由这个思路就产生了补码的运算规则：      符号位不变和最后一个1及其后部分不变，其余部分取反    原码取反加一    你可以手算一下$-2$的$64$位补码验证一下，是否与$-2$的同余正数$-2\\mod2^{64}$的值相同"
  },
  
  {
    "title": "Java集合",
    "url": "/posts/java%E9%9B%86%E5%90%88/",
    "categories": "软件开发, Java",
    "tags": "集合, Java",
    "date": "2023-05-23 21:36:00 +0800",
    





    
    "snippet": "01 学习目标  概述部分：      什么是java集合    java集合的特点    java的集合框架的体系结构图    常用的集合类    List、Set、Map的区别    集合框架的底层数据结构    哪些集合类是线程安全的    java集合的快速失败机制 “fail-fast”    如何确保一个集合不能被修改    Collection接口部分：      List接口...",
    "content": "01 学习目标  概述部分：      什么是java集合    java集合的特点    java的集合框架的体系结构图    常用的集合类    List、Set、Map的区别    集合框架的底层数据结构    哪些集合类是线程安全的    java集合的快速失败机制 “fail-fast”    如何确保一个集合不能被修改    Collection接口部分：      List接口    Set接口    队列    Map接口部分：      HashMap的实现原理    TreeMap的实现原理    HashMap的put方法的具体流程    HashMap的扩容操作实现    HashMap如何处理哈希冲突    能否使用任何类作为Map的key，为什么String、Integer这样的包装类适合作为key    如果想要使用Object作为HashMap的key，应该怎么做    HashMap为什么不直接使用hashcode方法处理后的值作为table的下标    HashMap的长度为什么是2的幂次方    HashMap与HashTable的区别    HashMap与TreeMap如何选择    ConcurrentHashMap的底层实现    HashMap与ConcurrentHashMap的区别    HashTable与ConcurrentHashMap的区别  02 集合概述什么是Java集合用于存储和操作Java对象的类和接口Java集合的特点与数组对比可以很好的体现Java集合的特点：  数组的大小是手动指定的，集合大小是自动分配的，且装满后按照扩容机制自动扩容  数组中的元素可以是原始类型，集合中不能放原始类型  遍历数组要使用循环，遍历集合可以用迭代器Java集合框架的体系结构Java集合框架以Collection接口和Map接口两个顶层接口为核心，结合具体的逻辑数据结构和物理数据结构，有不同的集合类。为什么要把Collection和Map作为顶层接口呢？因为java中接口是一种规范和约束，规范什么呢？规范可以对这个接口做什么操作。所以，对于集合而言，元素是value的操作和&lt;key ,value&gt;的操作肯定不同，所以顶层设计两个接口：Collection对应单一值value，Map对应键值对&lt;key,value&gt;，在这两个接口中定义了对这两类元素分别有哪些常用操作。常用的类有哪些Collection接口：  List子接口：ArrayList、LinkedList、Vector、Stack  Set子接口：TreeSet、HashSet、LinkedHashSetMap接口：  HashMap、TreeMap、HashTable、ConcurrentHashMap、PropertiesJava集合框架中哪些类是线程安全的  Vector：就比Arraylist多了个同步机制，但是效率太低，几乎不用  HashTable：就比HashMap多了个同步机制，也是早期实现  ConcurrentHashMap：比HashTable在高并发下效率更高  Java 5之后引入了java.util.concurrent包，提供了更多高效的并发集合类，ConcurrentHashMap就是其中之一。List、Set、Map的区别  List和Set是Collection接口的子接口，元素是单一的Value值，而Map元素类型是键值对&lt;key,value&gt;  List是列表，元素顺序确定，Set是集合元素顺序不确定  List中元素可重复，Set中元素不可重复集合框架底层的数据结构Collection接口：  List：          ArrayList：Object数组      Vector：Object数组      LinkedList：双向链表        Set：          HashSet：HashMap      TreeSet：TreeMap -&gt; 红黑树（自平衡排序二叉树）      LinkedHashSet：        Queue：Map接口："
  },
  
  {
    "title": "使用github pages创建个人网站",
    "url": "/posts/%E4%BD%BF%E7%94%A8github-pages%E5%88%9B%E5%BB%BA%E4%B8%AA%E4%BA%BA%E7%BD%91%E7%AB%99/",
    "categories": "个人项目",
    "tags": "github pages, 个人网站",
    "date": "2023-05-23 14:01:00 +0800",
    





    
    "snippet": "01 前言首先，本文目的是搭建个人网站，搭建个人网站有很多方法，之前尝试过租用云服务器，使用wordpress搭建，运行了一年时间，没有继续运行下去。主要原因有以下几点：  云服务器是付费的  域名需要购买，并且网站需要备案，流程复杂  使用wordpress搭建的网站上传新文章比较麻烦，不利于频繁更新所以，当了解到github pages可以解决上述烦恼时，毫不犹豫的选择采用github ...",
    "content": "01 前言首先，本文目的是搭建个人网站，搭建个人网站有很多方法，之前尝试过租用云服务器，使用wordpress搭建，运行了一年时间，没有继续运行下去。主要原因有以下几点：  云服务器是付费的  域名需要购买，并且网站需要备案，流程复杂  使用wordpress搭建的网站上传新文章比较麻烦，不利于频繁更新所以，当了解到github pages可以解决上述烦恼时，毫不犹豫的选择采用github pages来搭建个人网站。  github pages 原理  通过Jekyll解析你的github中名为username.github.io的仓库，发布到username.github.io域名上。其中Jekyll 是一个静态网站生成器。它以 Ruby 语言开发，被广泛用于构建静态网站、博客和文档站点。与Jekyll类似的当然还有很多静态网站生成器，这里选择GitHub官方支持的Jekyll。  警告  使用静态网站生成器时，一定不能惯性思维，认为想要修改哪个页面就找到页面的html文件，直接修改，这些网站生成器的特点就是，html等页面是根据配置文件生成的，所以，我们只需要修改配置文件，就能达到修改页面的目的。Jekyll的配置文件是网站根目录下的_config.yml，当我们需要调整页面时，需要修改这个文件。02 Github Pages 用法既然是借助github构建个人网站，那么即使我们本地没有任何运行环境也可以。但是如果想在文章发布前在本地进行预览和修改，就需要在本地准备jekyll的运行环境，上面提到了jekyll是ruby语言开发的，所以还需要安装ruby运行环境。  友情提示  如果想要在本地也能运行网站，会比只使用github pages搭建线上运行的网站多花费几倍甚至十几倍的时间。好处是，在刚开始不熟悉Jekyll时，需要修改页面、文章等来熟悉整个系统的使用，如果没有本地环境，每次修改都上传到github，再由Jekyll自动渲染的话，这个过程非常慢，如果有本地环境，基本上可以做到实时查看修改的效果。方案一：不配置本地运行环境1. 选择一个网站主题从官方主题网站 http://jekyllthemes.org/ 中，选择一个主题，进入主题的github主页2. fork主题一般如果是个人网站，fork到个人的仓库中时，仓库命名应该为username.github.io点击项目主页中，项目名称下方菜单栏依次点击settings-&gt;pages-&gt;Build and deployment，选择master分支，点击保存。等待片刻，就可以访问acsele.github.io了，如果要进行进一步的个性化设置，继续下面的步骤。3. 克隆到本地在fork后的个人项目username.github.io主页，项目文件列表右上方的code-&gt;https，复制项目的github地址，用于本地克隆。本地打开一个命令行终端窗口，跳转到合适的文件夹，执行git clone “复制的项目https地址”4. 完成readme教程中bundle命令前的步骤  友情提示  bundle命令及其后的内容是在本地搭建网站运行环境，我们不需要本地环境，所以到此为止，后面的工作，当我们把项目push到github的username.github.io仓库后，github会使用Jekyll帮我们完成。5. 提交到github在项目的根目录下使用Git GUI程序提交，或者依次执行：git add .git commit -m \"提交信息\"git push  不同的主题安装细节不同，而且即使是官方主题网站，很多主题也需要许多额外配置才能达到和项目样例接近，很多主题并不是即开即用，而且，由于在线环境使用github自动部署，因此需要一段时间的延迟，这就导致无法及时发现是因为没有正确配置，还是因为有延迟，导致最终页面效果不理想。因此还是用其他人推荐的主题，或者直接fork其他人的项目，然后添加文章，比较稳妥。方案二：配置本地运行环境  不同系统的jekyll安装教程地址：https://jekyllrb.com/docs/installation/以下步骤以Windows为例：1. 安装ruby和Jekyll  从RubyInstaller Downloads下载并安装Ruby+Devkit版本。使用默认选项进行安装。  运行ridk install安装向导最后阶段的步骤。这是安装带有本机扩展的 gem 所必需的。您可以在RubyInstaller 文档中找到关于此的更多信息 。从选项中选择MSYS2 and MINGW development tool chain。  从开始菜单打开一个新的命令提示符窗口，使对PATH环境变量的更改生效。安装 Jekyll 和 Bundler 使用gem install jekyll bundler  检查 Jekyll 是否安装正确：jekyll -v3. 根据Gemfile安装依赖在项目根目录下打开命令行窗口，执行bundle命令4. 启动Jekyll网站项目根目录下打开命令窗口，执行bundle exec jekyll s稍等片刻，项目可以在http://127.0.0.1:4000访问03 使用Jekyl的常见问题Markdown文件中图片路径问题原因分析：  Jekyll中默认_post文件夹下只放置md文件，所以解析时只处理文本文件，图片会被忽略。  Jekyll会将md文件中图片的相对路径加上前缀：\\_site\\posts\\{文件名}解决方案：  使用绝对路径  使用在线图片这两种都是下下策，但是还没发现其他办法全局问题  配置文件哪怕写错或多写一个字母，github pages自动部署时就无法正常显示页面，但是本地测试可以04 jekyll使用技巧4.1 使用插件自动新建文章插件地址：https://github.com/jekyll/jekyll-compose常用命令：  bundle exec jekyll help：查看帮助  bundle exec jekyll post “My New Post”：新建文章  新建的文章头部会有文章的元数据，可以修改文章的归档信息、数学公式渲染等"
  }
  
]

