---
layout: post
title: 补码的原理
date: 2023-07-15 23:13 +0800
math: true
categories:
- 专业基础知识
- 计算机组成原理
tags:
- 补码
---

## 补码为什么能把减法转换成加法

### 01 补码的核心思想——模算术

首先，能把减法转换成加法的前提一定是**有限的**数据表示范围，例如钟表的12个整数（可以表示1~12，也可以是-10~1等等）、64位计算机的$2^{64}$（可以表示有符号数 $-2^{63}\sim2^{63}-1$  ，或者无符号数$ 0 \sim 2^{64}-1$）。如果没有任何像前面的条件，直接问你$4-2$应该等于4加哪一个正整数，那一定是不存在的，即   $4-2=4+x  $   中正整数x不可能存在。

但是，如果有了一个有限的数据表示范围，利用”模算数“就可能求出上面的x。

> **模算数**或称**同余运算**（英语：Modular arithmetic）是一个[整数](https://zh.wikipedia.org/wiki/整数)的[算术](https://zh.wikipedia.org/wiki/算术)系统，其中数字超过一定值后（称为模/馀数）后会“卷回”到较小的数值，模算数最早是出现在[卡尔·弗里德里希·高斯](https://zh.wikipedia.org/wiki/卡爾·弗里德里希·高斯)在1801年出版的《[算术研究](https://zh.wikipedia.org/wiki/算术研究)》一书中。
>
{: .prompt-info}



就像钟表的算术系统中，$12+1=1$ ，这个过程就是 ” **卷回** “。需要注意的是，其中加法的加数、被加数，都必须在你所选定的数据表示范围内，显然对于这个范围外的数都属于非法的数。

上面的钟表系统中，如果你选定的12个连续整数是 -6~5，我们尝试在这个算术系统中计算上面的x，在钟表系统中，-2也就是逆时针旋转2个单位，相当于顺时针旋转10个单位，所以-2在钟表算术系统中就等于10，上面的4-2就应该等于4+10=2。

> **-2等价于10 是如何求的？4+10=2是如何求的？**
>
> 首先，还是要强调，这两个运算的前提都是在有限的数据表示范围内，这里有限的数据范围就是-6到5，共12个数。
>
> 如果你能画出钟表的示意图，这些问题是很直观可以看出来的，当然这个过程也有严格的数学运算的定义，即$mod$模算术：
>
> **若有两个正整数a和b，并且二数的差值a−b为n的整数[倍数](https://zh.wikipedia.org/wiki/倍數)，我们就可以说a和b在模n下同余或a与b同余模n。**
>
> **数学式表达为：$a \equiv b\mod n$**
>
> 注意，a可以有许多值，只要满足上面的定义。例如：
>
> - $-8 \equiv 7 (\mod 5)$ 
> - $-3 \equiv 7(\mod 5)$
> - $2 \equiv 7 (\mod 5)$ 
>
> mod右侧的数其实就是该算术系统中的数字个数，也可以理解成周期函数的周期。
>
> 虽然定义如此，但是大多数编程语言中的模算术运算（一般用%表示），结果都是一个确定值，应该选取哪个呢，不同的编程语言有不同的定义，[IEEE 754](https://zh.wikipedia.org/w/index.php?title=IEEE_754-1985&action=edit&redlink=1) 定义了一个取余函数，商被定义为 $\dfrac{b}{n}$依据[舍入约定](https://zh.wikipedia.org/w/index.php?title=IEEE_754-1985&action=edit&redlink=1)取整，余数选定为*最接近0*的。
>
{: .prompt-tip}

根据上面的理论，对于任何一个mod运算，如果算术系统中的数字比较少，你完全可以尝试将其看做一个钟表，算术系统中有几个数，就把钟表等分为几份，数据范围是多少就依次标出每个刻度处的数字。由得到的新的钟表，对任何算术系统中的数，你都把其转化成同余数字进行计算。例如，假设一个算术系统中有8个数，数据范围是-4到3，则你所得到的钟表从最上方的数字顺时针依次是：3、-4、-3、-2、-1 、0 、1 、2。

根据这个钟表，就可以实现用加法代替减法，例如：$3-4=3+(-4)=3+4=-1$，即共8个数的钟表上逆时针走4个单位，等于顺时针走4个单位。在上面等式中有$3-4=3+4$即$7=-1$，这在一般情况下当然是错误的，但是在当前只有8个数的算术系统中，就是正确的，其实更严谨的写法应该是$7\equiv -1 (\mod 8) $，即$7和-1$同余模8。

结合刻度为12的钟表例子，定义中模为5的同余数例子，以及模为8的例子，不难发现，在数据表示范围内的负数对应的最小同余正数，其实就是把该负数加上算术系统中数字个数。

> **为什么要计算最小同余正数，而不是随便取一个同余正数**
>
> 理论上取任何一个同余正数，最终的结果都是一样的，用周期函数的思想，其实就相当于多加了一个周期，用钟表的思想，相当于钟表顺时针多转了一圈，指向的还是同一个位置。但是数字越大，就越难计算。同时最小同余正数也符合IEEE754对模运算符的定义。
{: .prompt-tip}

### 02 补码是如何实现加法代替减法的

下面我们开始基于上面的思想分析补码的原理：

上面多次强调，模算术的前提是有限数据范围的算术系统，计算机显然符合这个条件，即使是现在主流的64位计算机，能表示的数据范围仍然是有限制的（最大是$2^{64}-1$），这就非常nice，因为我们可以按照上面的思想，画出来一个超大钟表，有$2^{64}-1$个刻度，假设现在我们要计算有符号整数，那么数据范围应该是$-2^{63}\sim 2^{63-1}$。

在这个范围内我们尝试用加法代替减法计算$4-2$：

- 第一步显然是计算$-2$对应的最小同余正数：$-2\mod2^{64}$

- 用加法代替减法，计算$4+(-2\mod2^{64})$

-  具体过程：

  $$ 4-2=4+(-2\mod2^{64})=\underbrace{0\cdots 04 }_{16}H+\underbrace{F\cdots FE }_{16}H=1\underbrace{0\cdots 02 }_{16}H=2 $$

上面的步骤中，我们没用到经常听到的求补码的规则（原码取反加一），但是仍然得到了正确结果。即使没有所谓的补码定义，我们好像也能用最小同余正数的概念，实现用加法代替减法的目的，那为什么还会出现补码的定义，以及求补码的规则呢？

> 首先明确的是，如果没有补码，计算机中是无法实现加法代替减法的，当然手算可以。如果仔细思考上面求最小同余数的过程，不难发现，$-2\mod2^{64}=-2+2^{64}$本质上还是一个减法，所以你在尝试用加法替换减法的过程中又使用了减法，这显然是不合理的。
>
> 但是这个过程告诉我们可以通过一个正数$-2\mod2^{64}$，代替-2，实现用加法代替减法，现在就是要想办法不通过减法计算$-2\mod2^{64}$，由这个思路就产生了补码的运算规则：
>
> - 符号位不变和最后一个1及其后部分不变，其余部分取反
> - 原码取反加一
> 
> 你可以手算一下$-2$的$64$位补码验证一下，是否与$-2$的同余正数$-2\mod2^{64}$的值相同
{: .prompt-tip}
